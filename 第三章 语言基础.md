# 第三章 语言基础

* ## 3.1 函数调用

  * ### 3.1.1 函数调用过程

    * C语言

      当在x86_64机器上使用C语言去调用函数的时候，参数是通过寄存器和栈传递的

      对于参数小于等于六个的情况，分别使用edi，esi，edx，ecx，r8d, r9d六个寄存器传递

      对于参数大于六个的情况，会通过栈传递，函数的参数从右向左的顺序依次传入栈中

      函数的返回值使用过eax寄存及进行传递的，因为只能使用一个寄存器，所以C语言中不能同时返回多个值

    * Go语言

      Go语言传递参数和传入返回值都在是栈上，所以可以返回多个值

    * 对比

      对于C语言，可以极大的减少函数调用的额外开销，但是增加了实现的复杂度。CPU访问栈的开销要比寄存器高，需要单独处理函数参数过多的情况

      对于Go语言，不需要考虑超过寄存器数目的参数应该如何传递；不需要考虑不同架构上寄存器差异；函数的参数传入和传入需要在栈上分配

  * ### 3.1.2参数传递

    Go语言对于**整形**和**数组**类型的参数都是**值传递**类型，也就是进行拷贝操作。与之相对比的是**传引用**类型，函数调用的时候会传递参数的指针，被调用方和调用方持有相同的数据，任意一方修改都会影响另一方

    对于**指针**作为参数传入到函数中，函数内部会对指针进行赋值，指向原来的内存空间。

    因此，在传递数组或者内存占用非常大的结构体时，我们在一些函数中应该尽量使用指针作为参数进行传入，这样相比的话，指针的复制要比数组或者结构体的赋值性能要好

    

* ## 3.2 接口

  接口就是计算机系统中多个组件共享的边界，接口的本质就是引入一个中间层，调用方何以通过接口和具体的实现分类，解除上下层的耦合，上层的模块不再下层的耦合，直接调用接口即可

  Go与袁仲，接口的定义需要使用interface关键词，在接口中，只能定义方法签名，不能包含成员变量。

  * ### 隐式接口

    **Go语言的接口实现都是隐式的**。 怎么去理解这个隐式，当我们定义一个error接口的时候，在java中需要在对应的位置声明，如果有问题，需要去调用你定义的这个接口。但是在go中，并不需要显示的声明，当发生相应的问题时，go会去直接调用你定义的接口

  * ### 类型

    * iface

      带有一组方法的interface 

    * eface

      不带任何方法的interface

    interface并不是任意类型，如果将一个变量变成 interface类型，这个变量在运行的时候类型就变成了interface类型。

    **在通过结构体或者指针实现接口的时候，有一个需要注意的地方。**

    ```go
    package main 
    
    import "fmt"
    
    type TestStruct struct{}
    
    func NilorNot(v interface{}) bool {
      return v == nil 
    }
    
    func main() {
      var s *TestStruct
      fmt.Println(s == nil)
      fmt.Println(NilorNot(s))
      fmt.Println(s == nil)                      
    }
    
    // true
    // false
    // true
    ```

    **第二个之所以输出false。是因为发生了隐式转换，从nil转换成了interface**

    我们把结构体初始化分为两种，一种是通过结构体指针进行赋值。一种是通过结构体直接进行赋值。

    然后再把调用的函数参数分为刘昂中，一种是把参数设置为结构体指针，一种是把参数设置为结构体

    |                  | 结构体作为函数 | 结构体指针作为函数参数 |
    | ---------------- | -------------- | ---------------------- |
    | 结构体初始化     | T              | F                      |
    | 结构体指针初始化 | T              | T                      |

    对于四种情况分别讨论一下：

    * **结构体初始化，结构体作为参数**。类型相同，代码通过编译
    * **结构体指针初始化，结构体作为参数。** 结构体指针初始化的时候，是相当于复制了指向原来内存的结构体，就相当于两个指针指向了同一块内存，可以看成是指向了一个相同并且唯一的结构体，所以是可以通过编译的
    * **结构体指针初始化，结构体作为参数。** 类型相同，代码通过编译
    * **结构体初始化，结构体指针作为函数参数。**因为参数类型是指针类型，编译器并不会创建一个新的指针，并且这个指针创建之后，指向的也不是原来的结构体

  * ### 数据结构

    再回到两种接口类型的讨论中。一种是iface，另一种是eface。

    eface的结构体定义只包含两个指针，分别是是指向底层数据和 \_type类型的type指针。

    另一种是iface，包含指向原始数据的指针data，还有itab类型的tab字段

    type结构体包含了类型的大小，哈希（用于快速的判断类型是否相等），对齐等

    itab结构体包含了type结构体还有一个动态数组，功能类似于虚函数表

  * ### 类型转换

    看不太懂，后续填坑

  * ### 类型断言

    上述讲的隐式接口可以实现将具体的类型转换成接口类型，接下来的类型断言可以将一个接口类型转换成具体类型

    /*看不太懂，后续填坑*/

  * ### 动态派发

    运行期间选择具体多态操作执行的过程。调用接口类型的时候，如果编译期间无法确定类型，在运行期间Go语言会决定具体调用通过什么方式去实现