# 第二章 数据结构

* ## 2.1 数组

  数组就是由相同类型元素的集合组成的数据结构。由一块连续的内存来进行存储

  * ### 2.1.1 初始化

    Go中数组初始化分成两种。一种是显式指定数组的大小。另一种是定义好数组中元素类型和个数的时候，由编译器自动进行推导

    ```go
    arr1 := [3]int{1, 2, 3}
    arr2 := [...]int{1, 2, 3}
    ```

    **语句转化**

    当元素的数量小于等于4的时候，数组中的变量初始化是直接在栈上初始化的。

    当元素的数量大于4的时候，变量先在静态存储区初始化，然后再拷贝到栈上（可能是因为栈上初始化需要对变量一个一个的赋值，而静态区的话，可以把整个内存复制过去）

  * ### 2.1.2 访问和赋值

    数组和字符串的简单的越界问题会在编译的时候检查出来，但是如果是通过变量去访问的话，就需要在运行的时候去发挥作用了。

    如果在运行的时候发现问题，会触发error导致程序崩溃退出

    

* ## 2.2 切片

  切片是动态数组，长度并不固定，可以随时加入元素，如果size不够的话，切片还会动态扩容

  ```go
  []int
  []interface{}
  ```

  切片的底层实现类似于sds。

  ```go
  type SliceHeader struct 
  {
      Data uintptr
      Len int
      Cap int
  }
  ```

  uintptr代表的当前元素的指针，Len代表当前切片的长度，Cap代表当前切片的容量

  * #### 2.2.1 初始化

    初始化有三种方式。

    ```go
    func newSlice() []int
    {
        arr := [3]int{1, 2, 3}
        slice := arr[0:1]
        return slice
    }
    /*第一种初始化方式，通过下标获得数组或者切片的一部分*/
    
    slice := []int(1, 2, 3)
    /*第二种初始化方式，通过字面量初始化*/
    
    slice := make([]int, 10)
    /*第三种初始化方式，通过make关键字创建*/
    ```

    * **字面量**

      ```go
      var vstat [3]int
      vstat[0] = 1
      vstat[1] = 2
      vstat[2] = 3
      
      var vauto *[3]int = new([3]int)
      *vauto = vstat
      slice :=vauto[:]
      ```

      字面量初始化的过程中

      * 首先创建一个数组
      * 对数组进行初始化
      * 创建一个新的数组指针
      * 对数组指针进行赋值
      * 通过下标创建的方式赋值给slice

    * **关键字**

      对于通过字面量的方式创建切片，大部分工作是在编译的期间确定的。但如果使用make关键字，很多内容是在运行的时候确定的。需要传入一个切片的大小和可选的容量

      如果 **切片的大小和容量足够小** 以及 **切片没有发生[逃逸](https://juejin.im/post/6844904176481206285)或者不是很大** 的时候

      ```go
      make([]int, 3, 4)
      //会转换成如下操作
      var arr [4]int
      n := arr[:3]
      ```

  * #### 2.2.2 追加和扩容

    向切片中追加元素通过append关键字实现。

    先对切片结构体进行解析，获取他的数组指针，大小和容量。如果需要进行扩容的话，会对切片进行扩容，然后加入新的元素。

    如果append之后的切片会覆盖掉原来的切片

    ```go
    slice - append(slice, 1, 2, 3)
    ```

    不需要担心切片的拷贝，编译器会对上述情况进行优化。如果size够用的话，还是返回原来的指针，如果需要进行扩容的话，会进行新的切片创建，然后进行赋值操作。

    扩容的策略：

    * 如果期望容量大于当前容量的两倍会使用期望容量

    * 如果当前的切片的长度小于1024，会进行翻倍操作

    * 如果当前的切片长度大于1024，每一次增加25%，直到到达期望容量

      

* ## 2.3哈希表
  * ### 2.3.1 开放寻址法

    如果发生hash冲突的话，将键值写到一个索引不为空的位置。当进行查找的时候，找到目标的key或者为null时停止寻找。

    开放寻址法中，对性能影响最大的就是装载因子的大小。装载因子越大，线性探测所花费的时间就越多。

  * ### 2.3.2 拉链法

    使用数组加上链表，不过也可以将链表改造成红黑树

  * ### 2.3.3 Go中的哈希表的实现

    * #### 初始化

      当哈希表中的元素小于等于25个的时候，扁你其直接将所有的kv键入到哈希表中；

      当元素个数大于等于25的似乎后，编译期间会创建两个数组分别存储kv的信息

    * #### 运行

      分为一下步骤：

      1. 计算hash所占用的内存是否超出上限
      2. 获取随机的hash种子
      3. 计算出需要最小的桶的数目
      4. 创建保存桶的数组（如果桶的数目小于2^4时，使用溢出桶的可能性较低，这个时候会省略创建溢出桶的过程；如果桶的数目大于2^4时，会创建2^(B-4)个溢出桶）

    * #### 读写操作

      赋值语句左侧接受参数的个数决定了读写的不同方法

      ```go
      v := hash[key]
      v, ok := hash[key]
      ```

      对于第一种情况，返回的是key对应的指针；

      对于第二种情况，返回的是key对应的指针以及对应的值是否存在；

      首先讨论第一种方案，

      * 首先获得key对应的桶序号和hash值前8位的数字（tophash，为了较少比较的次数）；
      * 哈希值的最后几位用于确认桶序号，前8位用于加速访问
      * 当桶中的tophash和传入的tophash匹配后，会返回指针

      第二种方案在第一种方案的基础上增加了一个bool判断

      写入操作，首先对桶中的tophash进行比较，如果找到了对应的桶，然后再去找对应的键值。

      如果当前的键值已经存在，但是桶已经满了的话，会调用newoverflow函数创建桶或者使用noverflow来保存数据。新创建的通会追加到已经有的桶的末尾。

      如果当前的键值不存在的话，会将键移动到对应的内存空间并且返回键对应的值

    * #### 扩容

      触发哈希扩容的两种情况：

      * [装载因子](https://www.cnblogs.com/east7/p/12594259.html)已经超过了6.5
      * 哈希使用了太多溢出桶

      对于使用了太多的溢出桶，会创建新桶保存数据，然后垃圾回收会清理老的溢出桶；

      哈希表在扩容的时候，分为两种扩容方式。一种是等量扩容，另一种是翻倍扩容。

      在扩容的期间，如果有对数据的访问操作，原来的桶会放入old bucket和oldoverflow中，访问的请求就会到oldbucket和oldvoerflow中。然后如果有写入的时候，会对哈希表的内容进行增量的拷贝，触发旧桶元素的分流。

    * #### 删除

      和扩容类似，显式进行寻找key的操作，然后进行删除操作。如果删除期间遇到了hash表的扩容，会对操作进行分流

      

* ## 2.4 字符串

  字符串在Go语言中，基本类型是string，并不支持直接修改，但是可以通过拷贝来实现。但是[]byte中的内容是可以读写的

  * ### 2.4.1 解析过程

    在Go中，有两种字面可以声明一个字符串

    ```go
    str1 := "this is a string"
    str2 := `this is anonter
    string`
    ```

    对于第一种情况，如果字符串内部出现了 ”，需要通过转义符 '\\' 来进行转义；

    对于第二种情况，可以指焊接在字符串内部直接使用“，双引号不再负责标记字符串的开始和结束

  * Go的字符串是支持+拼接的，如果要拼接的字符串小于等于五个，会直接调用concatstring。如果要拼接的字符串大于五个，会传入一个数组切片。对传入的切片进行遍历，过滤空字符串之后计算拼接字符串的长度

  * ### 类型转换

    当使用Go语言解析和序列化JSON数据格式时，需要将数据在string和[]byte之间转换，这个开销时比较大的。

    从[]byte到string，stringStructOf回将传入的字符串指针转换成stringstruct结构体指针，然后设置字符串指针str和len，最后通过memmove将原来[]byte中的字节复制到内存空间中

    从string到[]byte，需要使用stringtoslicebtye，先看是否已经传入缓冲区。如果没有的话，会创建一个新的字节切片，然后就会将字符串中的内容拷贝到[]byte中

    

    

## 总结

第二章的数据结构，主要讲了 数组，切片，哈希表，字符串。

数组，首先是如何进行定义，和C++类似，可以直接指定，也可以由编译器进行自动推断。

切片，类似于C++中的vector，会进行动态扩容。扩容的触发条件存在三种。初始化的方式也是有三种。还有一个就是在通过字面量进行初始化时，需要考虑到逃逸这种情况

哈希表，主要目的是为了增加读写的效率。介绍了两中基本的hash方法，拉链法和线性探测法。分析了线性探测法的优缺点，以及装载因子的概念。对于拉链法，提到了一个改进方式，就是将链表改进成红黑树。在拉链法的基础上，讲解了具体的实现，如何根据哈希值确定桶，如何根据哈希值减少遍历的范围，溢出桶的设计（为了减少扩容的频率）。如何进行扩容和删除，扩容的触发条件。

字符串，主要讲了string和[]byte的区别，相互之间的赋值操作，两种定义方式





