# 第五章 并发编程

* ## 5.1 上下文Context

  上下文Context是用来设置截止日期，同步信号，传递请求相关值的结构体。

  ```go
  type Context interface {
      Deadline() (deadline time.Time, ok bool)
      // 返回context.Context被取消的时间，即完成工作的截止日期
      Done() <-chan struct{}
      // 返回一个channel
      Err() error
      // 返回context.Context结束的原因
      Value(key interface{}) interface{}
      // 从context.Context中获取键对应的值，可以用来传递请求特定的数据
  }
  ```

  * ### 5.1.1 设计原理

    Go服务的每一个请求都是通过单独的Goroutine处理的，我们可能会创建多个goroutine来处理一次请求，context的作用可以在不同的Goroutine之间同步请求特定的数据，取消信号和处理请求的截止日期，可以减少计算资源的浪费。

    每一个context都会从最顶层的Goroutine一层一层的传递到最下层。context可以在上层的goroutine执行出现错误后，及时的将信号同步给下层。如果没有这一个机制，下层的goroutine会继续执行，就会造成资源的浪费

  * ### 5.1.2 默认上下文

    context包中比较常用的有context.Background,context.TODO。这两个方法分别会返回预先初始化好的私有变量background和todo

    context.Background是上下文的默认值，所有其他的上下文都应该从它衍生出来；

    context.TODO应该旨在不确定应该使用那种上下文时使用；

  * ### 5.1.3 取消信号

    **context.WithCancel**

    context.WithCancel这个函数，能够从context.Context中衍生出一个新的子上下文，并且返回一个用于取消上下文的函数。当我们执行取消函数之后，当前的上下文还有他的子上下文都会被取消，所有的goroutine都会收到这一个取消信号。

    再观察withcancel具体做了什么:

    * newCancelCtx将传入的上下文包装成私有结构体 context.CancelCtx;

    * context.propagateCancel 会构建父子上下文之间的联系，当父上下文被取消时，子上下文也会被取消。

      接下来再对propagataCancel具体的功能进行解析：

      在构建夫子上下文的时候分为三种情况:

      1. 当parent不会触发取消事件的时候，当前的propagatacancel会立即返回

      2. 当child的继承链包含可以取消的上下文时，会判断parent是否已经触发了取消信号，

         如果parent已经被取消，child也会被取消；

         如果parent没有被取消，child会被加入parent的children列表中，等待parent释放取消信号

      3. 默认情况下，运行一个新的goroutine同时监听parent.Done和child.Done两个channel

      4. 在parent.Done时调用child.Done，取消子上下文

    **context.cancelCtx**

    对于context.cancelCtx会调用cancel，这个方法会关闭上下文的cancel并且向所有的子上下文同步取消信号（[Go中方法和函数的区别](http://www.mamicode.com/info-detail-2959122.html)）

    **context.WithDeadline**

    对于context.WithDeadline在创建context.timerCtx的过程中，判断了父上下文的截止日期和当前的日期，并且创建定时器，当超时后会调用context.timerCtx.cancal方法同步取消信号

    context.timerCtx内部嵌入了cancelCtx结构体，还通过定时器timer和截止时间deadline实现了定时取消。

    

    

