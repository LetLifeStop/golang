# 第五章 并发编程

* ## 5.1 上下文Context

  上下文Context是用来设置截止日期，同步信号，传递请求相关值的结构体。

  ```go
  type Context interface {
      Deadline() (deadline time.Time, ok bool)
      // 返回context.Context被取消的时间，即完成工作的截止日期
      Done() <-chan struct{}
      // 返回一个channel
      Err() error
      // 返回context.Context结束的原因
      Value(key interface{}) interface{}
      // 从context.Context中获取键对应的值，可以用来传递请求特定的数据
  }
  ```

  * ### 5.1.1 设计原理

    Go服务的每一个请求都是通过单独的Goroutine处理的，我们可能会创建多个goroutine来处理一次请求，context的作用可以在不同的Goroutine之间同步请求特定的数据，取消信号和处理请求的截止日期，可以减少计算资源的浪费。

    每一个context都会从最顶层的Goroutine一层一层的传递到最下层。context可以在上层的goroutine执行出现错误后，及时的将信号同步给下层。如果没有这一个机制，下层的goroutine会继续执行，就会造成资源的浪费

  * ### 5.1.2 默认上下文

    context包中比较常用的有context.Background,context.TODO。这两个方法分别会返回预先初始化好的私有变量background和todo

    context.Background是上下文的默认值，所有其他的上下文都应该从它衍生出来；

    context.TODO应该旨在不确定应该使用那种上下文时使用；

  * ### 5.1.3 取消信号

    **context.WithCancel**

    context.WithCancel这个函数，能够从context.Context中衍生出一个新的子上下文，并且返回一个用于取消上下文的函数。当我们执行取消函数之后，当前的上下文还有他的子上下文都会被取消，所有的goroutine都会收到这一个取消信号。

    再观察withcancel具体做了什么:

    * newCancelCtx将传入的上下文包装成私有结构体 context.CancelCtx;

    * context.propagateCancel 会构建父子上下文之间的联系，当父上下文被取消时，子上下文也会被取消。

      接下来再对propagataCancel具体的功能进行解析：

      在构建夫子上下文的时候分为三种情况:

      1. 当parent不会触发取消事件的时候，当前的propagatacancel会立即返回

      2. 当child的继承链包含可以取消的上下文时，会判断parent是否已经触发了取消信号，

         如果parent已经被取消，child也会被取消；

         如果parent没有被取消，child会被加入parent的children列表中，等待parent释放取消信号

      3. 默认情况下，运行一个新的goroutine同时监听parent.Done和child.Done两个channel

      4. 在parent.Done时调用child.Done，取消子上下文

    **context.cancelCtx**

    对于context.cancelCtx会调用cancel，这个方法会关闭上下文的cancel并且向所有的子上下文同步取消信号（[Go中方法和函数的区别](http://www.mamicode.com/info-detail-2959122.html)）

    **context.WithDeadline**

    对于context.WithDeadline在创建context.timerCtx的过程中，判断了父上下文的截止日期和当前的日期，并且创建定时器，当超时后会调用context.timerCtx.cancal方法同步取消信号

    context.timerCtx内部嵌入了cancelCtx结构体，还通过定时器timer和截止时间deadline实现了定时取消。

  * ### 5.1.4 传值方法

    context包中的context.WithValue函数能够从父上下文中创建一个子上下文，这个子上下文通过context.valueCtx类型进行传递
  
    
  
* ## 5.2 同步原语与锁

  Go是支持用户态进程的语言，锁可以保证多个Goroutine在访问同一片内存时不会出现竞争条件。接下来会讲Go中的sync.Mutex, sync.RWMutex, sync.WaitGroup, sync.Once和sync.Cond以及扩展原语 errgroup.Group，semaphore.Weighted和singleflight.Group的实现原理

  * ### 5.2.1 基本原语

    mutex，REWMutex，WaitGroup，Once，Cond

    #### Mutex

    Go语言中的sync.Mutex由state和sema两个字段构成。

    ```go
    type Mutex struct {
        state int32
        sema uint32
    }
    ```

    state表示状态，sema表示控制锁状态的信号量。

    state中最低的三位分别表示mutexLocked，mutexLocked，mutexWoken和mutexStarving，剩下的位置用来表示当前有多少个Goroutine等待互斥锁的释放

    **互斥锁的状态：**

    1. mutexLocked 表示互斥锁的锁定状态
    2. mutexWoken 表示唤醒状态
    3. mutexStarving 当前的互斥锁进入饥饿状态
    4. waitersCount 当前的互斥锁上等待的Goroutine个数

    **正常模式和饥饿模式**

    在正常模式下，锁的等待者分为两类，等待队列中的Goroutine和刚创建的Goroutine，这两类会对锁进行竞争，如果等待队列中的Goroutine在超过1ms的时间内没有获取到锁，为了减少等待延迟，会从正常模式转换到饥饿模式。

    在饥饿模式中，新的Goroutine不能获取锁，新请求的Goroutine会被强制放入到等待队列的尾部。等待队列的头部优先级最高。

    **加锁和解锁**

    加锁是通过sync.Mutex.Lock实现的，解锁是通过sync.Mutex.Unlock实现的

    当锁的状态是0的时候，将mutexLocked位置标注为1，如果互斥锁的状态不是0，会调用sync.mutex.lockslow通过[自旋](https://blog.csdn.net/loveqishan/article/details/89874249)的形式等待锁的释放，大概过程分为：

    1. 判断当前的Goroutine能够进入自旋

       能够进入自旋的条件:

       1. 互斥锁在普通模式下
       2. 运行在多CPU的机器上
       3. 当前的Goroutine为了获取该锁进入自旋的次数小于四次
       4. 当前机器上至少存在一个正在运行的处理器并且处理的运行队列为null

    2. 通过自旋等待互斥锁的释放

    3. 计算互斥锁的最新状态（根据上下文计算当前互斥锁最新状态）

    4. 更新互斥锁的状态并且获取锁（通过CAS函数进行更新）

    获取锁之后，如果在正常模式下，这段代码会设置唤醒和饥饿标记，重置迭代次数并重新执行获取；如果在饥饿模式下，当前的Goroutine会获得互斥锁，如果等待队列只存在当前的Goroutine，互斥锁会从饥饿模式下退出

    解锁模式相对于加锁模式会简单一些， 首先调用addint32函数进行解锁，如果该函数返回的新状态等于0，当前的Goroutine就成功的解锁了互斥锁。如果返回的新状态不是0，这段代码会调用unlockslow开始慢速解锁。如果当前互斥锁已经被解锁过了会抛出异常，此外

    分成两种情况去进行慢速解锁：

    * 正常模式下，如果互斥锁不存在或者互斥锁的mutexlocked，mutexStarving，mutexWoken状态都不为0，当前的方法就可以返回，不需要唤醒其他等待着；

      如果互斥锁存在等待着，会唤醒等待着并移交锁的所有权

    * 饥饿模式下，将当前的锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁

    

