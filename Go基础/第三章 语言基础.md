# 第三章 语言基础

* ## 3.1 函数调用

  * ### 3.1.1 函数调用过程

    * C语言

      当在x86_64机器上使用C语言去调用函数的时候，参数是通过寄存器和栈传递的

      对于参数小于等于六个的情况，分别使用edi，esi，edx，ecx，r8d, r9d六个寄存器传递

      对于参数大于六个的情况，会通过栈传递，函数的参数从右向左的顺序依次传入栈中

      函数的返回值使用过eax寄存器进行传递的，因为只能使用一个寄存器，所以C语言中不能同时返回多个值

    * Go语言

      Go语言传递参数和传入返回值都在是栈上，所以可以返回多个值

    * 对比

      对于C语言，可以极大的减少函数调用的额外开销，但是增加了实现的复杂度。CPU访问栈的开销要比寄存器高，需要单独处理函数参数过多的情况

      对于Go语言，不需要考虑超过寄存器数目的参数应该如何传递；不需要考虑不同架构上寄存器差异；函数的参数传入和传入需要在栈上分配

  * ### 3.1.2参数传递

    Go语言对于**整形**和**数组**类型的参数都是**值传递**类型，也就是进行拷贝操作。与之相对比的是**传引用**类型，函数调用的时候会传递参数的指针，被调用方和调用方持有相同的数据，任意一方修改都会影响另一方

    对于**指针**作为参数传入到函数中，函数内部会对指针进行赋值，指向原来的内存空间。

    因此，在传递数组或者内存占用非常大的结构体时，我们在一些函数中应该尽量使用指针作为参数进行传入，这样相比的话，指针的复制要比数组或者结构体的赋值性能要好

    

* ## 3.2 接口

  接口就是计算机系统中多个组件共享的边界，接口的本质就是引入一个中间层，调用方何以通过接口和具体的实现分类，解除上下层的耦合，上层的模块不再需要下层的耦合，直接调用接口即可

  Go语言中，接口的定义需要使用interface关键词，在接口中，只能定义方法签名，不能包含成员变量。

  * ### 3.2.1 隐式接口

    **Go语言的接口实现都是隐式的**。 怎么去理解这个隐式，当我们定义一个error接口的时候，在java中需要在对应的位置声明，如果有问题，需要去调用你定义的这个接口。但是在go中，并不需要显示的声明，当发生相应的问题时，go会去直接调用你定义的接口

  * ### 3.2.2 类型

    * iface

      带有一组方法的interface 

    * eface

      不带任何方法的interface

    interface并不是任意类型，如果将一个变量变成 interface类型，这个变量在运行的时候类型就变成了interface类型。

    **在通过结构体或者指针实现接口的时候，有一个需要注意的地方。**

    ```go
    package main 
    
    import "fmt"
    
    type TestStruct struct{}
    
    func NilorNot(v interface{}) bool {
      return v == nil 
    }
    
    func main() {
      var s *TestStruct
      fmt.Println(s == nil)
      fmt.Println(NilorNot(s))
      fmt.Println(s == nil)                      
    }
    
    // true
    // false
    // true
    ```

    **第二个之所以输出false。是因为发生了隐式转换，从nil转换成了interface**

    我们把结构体初始化分为两种，一种是通过结构体指针进行赋值。一种是通过结构体直接进行赋值。

    然后再把调用的函数参数分为刘昂中，一种是把参数设置为结构体指针，一种是把参数设置为结构体

    |                  | 结构体作为函数 | 结构体指针作为函数参数 |
    | ---------------- | -------------- | ---------------------- |
    | 结构体初始化     | T              | F                      |
    | 结构体指针初始化 | T              | T                      |

    对于四种情况分别讨论一下：

    * **结构体初始化，结构体作为参数**。类型相同，代码通过编译
    * **结构体指针初始化，结构体作为参数。** 结构体指针初始化的时候，是相当于复制了指向原来内存的结构体，就相当于两个指针指向了同一块内存，可以看成是指向了一个相同并且唯一的结构体，所以是可以通过编译的
    * **结构体指针初始化，结构体作为参数。** 类型相同，代码通过编译
    * **结构体初始化，结构体指针作为函数参数。**因为参数类型是指针类型，编译器并不会创建一个新的指针，并且这个指针创建之后，指向的也不是原来的结构体

  * ### 3.2.3 数据结构

    再回到两种接口类型的讨论中。一种是iface，另一种是eface。

    eface的结构体定义只包含两个指针，分别是是指向底层数据和 \_type类型的type指针。

    另一种是iface，包含指向原始数据的指针data，还有itab类型的tab字段

    type结构体包含了类型的大小，哈希（用于快速的判断类型是否相等），对齐等

    itab结构体包含了type结构体还有一个动态数组，功能类似于虚函数表

  * ### 3.2.4 类型转换

    看不太懂，后续填坑

  * ### 3.2.5 类型断言

    上述讲的隐式接口可以实现将具体的类型转换成接口类型，接下来的类型断言可以将一个接口类型转换成具体类型

    /*看不太懂，后续填坑*/

  * ### 3.2.6 动态派发

    运行期间选择具体多态操作执行的过程。调用接口类型的时候，如果编译期间无法确定类型，在运行期间Go语言会决定具体调用通过什么方式去实现
    
    
  
* ## 3.3 反射

  反射是能够动态获取变量类型信息和值信息的机制。

  reflect能够让程序操作不同类型的对象。反射包中有两个非常重要的函数，reflect.TypeOf 和 reflect.ValueOf。Typeof能获取任意变量的类型，valueof中提供了获取和写入数据的方法。

  * ### 3.3.1 三大原则

    反射作为一种[元编程](https://www.zhihu.com/question/23856985)可以减少重复的代码，但是过量的反射会让程序逻辑变得复杂。接下来介绍Go语言反射的三大法则

    * #### 第一法则

      从interface变量转换成反射对象。

      当我们调用reflect.ValueOf(1)的时候，int类型会转换成intereface类型。

      然后再调用reflect.TypeOf可以获取对象类型。

      ```go
      package main 
      
      import (
        "fmt"
        "reflect"
      )
                               
      func main() {
        author := "draven"
        fmt.Println("TypeOf author:", reflect.TypeOf(author))
        fmt.Println("ValueOf author:", reflect.ValueOf(author))
      }
      /*
      [huangqingxiang@izuf652dgp0qaxgu6b5g69z src]$ go run hello.go 
      TypeOf author: string
      ValueOf author: draven
      */
      ```

    * #### 第二法则

      我们可以从反射对象获取interface变量。在第一原则中，interface可以转化成reflect对象。那在第二法则中，这搁转换顺序是可以颠倒的。通过reflect.Value.Interface进行显式的类型转换

      ```go
      v := reflect.ValueOf(1)
      v.Interface().(int)
      ```

      双方进行颠倒的时候，需要进行两次转换

      对于从基本类型到反射：

      * 基本类型 -》interface
      * interface -》 reflect

    * #### 第三法则

      如果偶们想要更新一个reflect.Value，他持有的可以被更新。但是不能直接进行修改

      ```go
      i := 1
      v := reflect.ValueOf(i)
      v.SetInt(10)
      //会报错
      ```

      正确的做法

      ```go
      i := 1
      v := reflect.ValueOf(&i)                       
      v.Elem().SetInt(10)
      fmt.Println(i)
      ```

      首先获取变量的指针，然后获获取指针指向的变量，最后更新变量的值

      

  * ### 类型和值

    Go语言中interface在内部是通过emptyInterface结构体来表示的。

    当我们通过reflect去获取对象的类型时，rflect会隐式的转换成emptyface类型

    当我们通过reflect去修改对象的值时，先调用reflect.escape保证当前的值逃逸到堆上（为什么要到堆上？是为了防止并发条件吗），然后通过unpackEface获取value结构体。unpackEface回将接口转换成emptyInterface结构体，然后再封装成value结构体

    

  * ### 更新变量

    当我们通过set对reflect中的值进行更新时，set会检查当前reflect对象是否可以被设置以及字段是否被公开。如果可以的话，就会进行覆盖操作。

    

  * ### 实现协议

    reflect提供了reflect.rtypes.Implements方法用于判断某些类型是否遵循特定的接口。

    implement会检查传入的类型是不是接口，如果不是接口或着空就终止。

    

  * ### 方法调用

    使用reflect进行函数调用步骤

    * 检查输入参数以及类型的合法性
    * 将传入的value设置到栈上
    * 通过函数指针和输入参数调用函数
    * 从栈上获取返回值

    **参数检查**

    检查参数的个数，类型，和函数签名中类型是否可以匹配

    **准备参数**

    计算函数的参数和返回值，设置栈空间；

    如果有返回值，为当前的函数参数和返回值分配内存空间；

    将函数参数按照顺序拷贝到对应内存中；

    **调用函数**

    向函数中传入栈类型，函数指针，参数和返回值的内存空间，栈的大小和返回值的偏移量；

    **处理返回值**

    如果没有返回值，清空arg；

    如果有返回值

    1. 将和输入参数有关的内存清空；
    2. 创建一个切片用来保存返回值数组
    3. 从函数中获取返回对象的类型和大小，将arg中的数据转换成reflect.value然后存储到切片中

    

# 总结

主要讲了三个部分，函数调用，接口，反射

函数调用部分，讲了Go和C语言的函数调用在参数的传递，返回值个数，原理上的的区别；

接口讲了调用过程，参数的初始化，参数作为参数之间的组合以及非法情况。还有接口的两大类，iface，eface底层实现的不同，底层数据结构之间的转换；还有后续的类型断言和动态转换有点看不懂，留个坑；

反射讲了三大原则，参数的转换过程，参数的类型，访问，修改原理。然后再就是反射的一个具体调用过程，包括对函数参数和返回值的操作，变量的检查，函数的调用，返回值的处理



